# Использование респонсив верстки

## Срок сдачи работ

Последний коммит и пул реквест должен быть оформлен до ???

## Цель:

Повторить медиа селекторы с изменением корневого размера шрифта и ширину контейнера

### Брейкпоинты

-   1024
-   768
-   480

_Отступ у контейнера на всех вьюпортах - `2rem`_

### Таблица процентов к REM

| px   | Проценты |
| ---- | -------- |
| 8px  | 50%      |
| 9px  | 56.25%   |
| 10px | 62.5%    |
| 11px | 68.75%   |
| 12px | 75%      |
| 13px | 81.25%   |
| 14px | 87.5%    |
| 15px | 93.75%   |
| 16px | 100%     |

_Это задание будет требовать от вас использование REM везде, кроме `@media` запросов и ширины контейнера_

https://github.com/user-attachments/assets/0bf9525f-801b-4e3e-b504-bbf34ec91822

## Tips and Tricks

### "Масштабирование" интерфейса

#### ❌

Если устанавливать размеры элементов статичными единицами измерения, то их придется менять позже на брейкпоинте

```css
span {
    font-size: 16px;
    margin: 16px 32px;
}

@media screen and (max-width: 768px) {
    span {
        font-size: 14px;
        margin: 14px 28px;
    }
}
```

#### ✔️

Если использовать REM

```css
html {
    font-size: 62.5%;
    /* 16*0.625 = 10px */
    /* Соответственно 1rem => 10px */
}

body {
    font-size: 1.6rem;
    /* Возвращаем стандартный размер шрифта - 16px */
}

span {
    font-size: 1.6rem;
    margin: 1.6rem 3.2rem;
}

@media screen and (max-width: 768px) {
    html {
        font-size: 56.25%;
        /* 16*0.5625 = 9px */
        /* Уменьшаем интерфейс когда доходим до брейкпоинта */
    }
}
```

> [!CAUTION]
> REM хак может быть удобен, однако иногда его применение ломает логику дизайна (например, когда вам приходится переписывать интерфейс на мобильном устройстве) и у вас будет 2 выхода:
>
> -   Пересчитывать вручную все размеры с макета с тем `font-size` html'я, который у вас окажется на брейкпоинте экрана
> -   Поднимать обратно `font-size` до 62.5% (предпочтительнее)

> [!WARNING]
> Если с вас требуется pixel perfect дизайн на определенных вьюпортах, вы не используете никакие UI-киты в перемешку с вашим CSS кодом, а адаптивная верстка просто должна работать, то это суперски сэкономит время и силы. Если вам необходимо придерживаться логики "доступность > как в макете", то это метод проб и ошибок (неплохая [статья](https://www.joshwcomeau.com/css/surprising-truth-about-pixels-and-accessibility/) про это)

_В рамках нашей дисциплины вы можете использовать любой подход (кроме пикселей везде), так как мы будем придерживаться доступности до тех пор, пока не будет мешать повторению макета_

### Логические свойства

#### ❌

`margin: 0 auto` является нелогическим свойством, которое всегда понимает лево-право относительно вьюпорта, а не элемента

#### ✔️

`margin-inline: auto` является логическим свойством, которое всегда применяет отступ относительно элемента

### Overflow контейнера по вертикали

#### ❌

`height: 100vh` - если контента будет больше, чем на один экран, то он будет отрезаться по контейнеру

#### ✔️

`max-height: 100vh` - если контента будет больше, чем на один экран, то он будет увеличивать высоту контейнера

### Overflow контейнера по горизонтали

#### ❌

`width: 144rem` - при достижении этой ширины придется писать медиа селектор на `width: 100%`

#### ✔️

`max-width: 144rem` - при достижении этой ширины контейнер автоматически станет занимать всю ширину родителя (window)

### Двойственность viewport единиц измерения на мобильных устройствах

Наличие "авто скрываемой" навигации в браузере заставляет обычные vh единицы измерения работать по-разному в разных браузерах

<img width="100%" src=".repo/vh.png" />

`dvh` не является решением всех проблем, так как при скролле меню скроется, а высота контейнера вырастет - элементы будут прыгать

_Поэтому чаще всего приходится решать в зависимости от ситуации и ТЗ_

# Интересное

-   [Статистика вьюпортов](https://gs.statcounter.com/screen-resolution-stats)
